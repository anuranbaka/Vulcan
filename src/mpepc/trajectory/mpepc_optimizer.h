/* Copyright (C) 2010-2019, The Regents of The University of Michigan.
 All rights reserved.

 This software was developed as part of the The Vulcan project in the Intelligent Robotics Lab
 under the direction of Benjamin Kuipers, kuipers@umich.edu. Use of this code is governed by an
 MIT-style License that can be found at "https://github.com/h2ssh/Vulcan".
*/


/**
* \file     mpepc_optimizer.h
* \author   Collin Johnson and Jong Jin Park
*
* Declaration of MPEPCOptimizer.
*/

#ifndef MPEPC_OPTIMIZER_H
#define MPEPC_OPTIMIZER_H

#include "mpepc/trajectory/params.h"
#include "mpepc/trajectory/robot_trajectory_info.h"
#include "core/pose.h"
#include <nlopt.h>
#include <vector>
#include <memory>

namespace vulcan
{
namespace mpepc
{

const int kOptimizationDimension = 5;

const int kIdxR     = 0;
const int kIdxTheta = 1;
const int kIdxDelta = 2;
const int kIdxVGain = 3;
const int kIdxK1    = 4;

/**
* optimizer_coords_t is a coordinate of optimization space for the MPEPCOptimizer,
* i.e. the argument to the objective function to be minimized.
*/
struct optimizer_coords_t
{
    double r;
    double theta;
    double delta;
    double velocityGain;
    double k1;
    double k2;

    explicit optimizer_coords_t(double r = 0,
                                double theta = 0,
                                double delta = 0,
                                double velocityGain = 0,
                                double k1 = 1.0,
                                double k2 = 1.0)
    : r(r)
    , theta(theta)
    , delta(delta)
    , velocityGain(velocityGain)
    , k1(k1)
    , k2(k2)
    {
    }

    explicit optimizer_coords_t(const double x[kOptimizationDimension])
    : r(x[kIdxR])
    , theta(x[kIdxTheta])
    , delta(x[kIdxDelta])
    , velocityGain(x[kIdxVGain])
    , k1(x[kIdxK1])
    {
    }

    void toArray(double x[kOptimizationDimension]) const
    {
        x[kIdxR]     = r;
        x[kIdxTheta] = theta;
        x[kIdxDelta] = delta;
        x[kIdxVGain] = velocityGain;
        x[kIdxK1]    = k1;
    }

    bool operator==(const optimizer_coords_t& rhs) const
    {
        return (r == rhs.r) && (theta == rhs.theta) && (delta == rhs.delta) && (velocityGain == rhs.velocityGain)
            && (k1 == rhs.k1);
    }

    bool operator!=(const optimizer_coords_t& rhs) const
    {
        return !(*this == rhs);
    }
};


class  RobotSimulator;
class  TrajectoryEvaluator;
class  TaskManifold;
struct motion_target_t;
struct trajectory_planner_debug_info_t;

/**
* MPEPCTrajectoryOptimizer handles the optimization task within the MPEPC planner.
* The optimizer recieves the simulator and the cost evaluator to use, along with
* the state for the current planning problem, i.e. planner_data_t, and finds the
* time-optimal trajectory in the form of a motion target.
*
* The optimizer handles the simulate/evaluate loop internally and finds the optimal
* target along with the intermediate trajectories generated by the optimization
* algorithm. NLopt package is used for the numerical optimzation, and a number of
* different algorithms can be implemented.
*/
class MPEPCOptimizer
{

public:

    /**
    * Constructor for MPEPCOptimizer.
    *
    * \param    params          Parameters for the optimization
    */
    MPEPCOptimizer(const mpepc_optimizer_params_t& params);

    /**
    * Destructor for MPEPCOptimizer.
    */
    ~MPEPCOptimizer(void);

    /**
    * Setup sets up the optmizer with the robot simulator and trajectory evaluator to be used.
    *
    * \param    simulator       RobotSimulator to use for the trajectory generation.
    * \param    evaluator       TrajectoryEvaluator for calculating the cost of a trajectory.
    */
    void setup(RobotSimulator& simulator, TrajectoryEvaluator& evaluator); // NOTE: This feels very unsafe. A better way?

    /**
    * setInitialGuesses adds a goal pose (if navigation task) and the previous optimum
    * to the initial guesses for local optimizer.
    *
    * \param    task                 TaskManifold that contains the goal.
    * \param    previousMotionTarget Previous output of the metric planner, i.e. the previous optimum.
    */
    void setInitialGuesses(const TaskManifold&    task,
                           const motion_target_t& previousMotionTarget);

    /**
    * run runs the optimizer and finds the best motion target by evaluating the expected
    * costs of an estimated trajectory generated from a candidate motion target.
    *
    * It returns the optimal target found, while the intermediate information including
    * all trajectories considered are stored in the provided debug info instance.
    *
    * \param    debugInfo        Place to store relevant information
    * \return   Optimal target found
    */
    motion_target_t runOptimizer(trajectory_planner_debug_info_t& debugInfo);

    /**
    * evaluateCost calculates the cost of a fixed-length trajectory represented by the given optimizer_target_t.
    * The length of the trajectory is specified in the given instance of the planner_data_t.
    *
    * \param    coords          Optimization variable, currently encoding a target pose in the robot frame and a velocity gain for the kinematic control law.
    * \return   Cost of the trajectory.
    */
    double evaluateCost(const optimizer_coords_t& coords);

    // get getSurvivability of the trajectroy associated with the optimizer coords. Will assert failure if the given coordinate is not the same as the one used for cost evaluation
    double getChanceConstraint(const optimizer_coords_t& coords);

    /**
    * evaluateGradient calculates the gradient around a particular point, by a simple forward differencing.
    *
    * \param    coords          Optimization variable, currently encoding a target pose in the robot frame and a velocity gain for the kinematic control law.
    * \param    cost            Evaluated cost at the given coordinate.
    * \param    gradient        Calculated gradient for each dimension (r, theta, delta, velocity) [output]
    */
    void evaluateGradient(const optimizer_coords_t& coords, double cost, double gradient[kOptimizationDimension]);

    bool haveFoundSolution(void) const { return haveFoundSolution_; };

//     /**
//     * evaluateSingleMotionTarget is a method which resets the data and info struct and evaluate a single optimizer target.
//     * The optimization_info_t will hold a single trajectory considered. TODO: Do i need this?
//     *
//     * \param candidateMotionTarget
//     * \param data
//     * \param info
//     */
//     double evaluateSingleMotionTarget(const motion_target_t& candidateMotionTarget, const planner_data_t& data, optimization_info_t& info);

private:

    // setting up the optimizer
    void setupGlobalOptimizer(void);
    void setupLocalOptimizer(void);

    // loading a predetermined set of initial points for local optimizer
    void loadGuessesFromFile(const std::string& filename);

    // checking if the target is within a specified bounds
    bool isTargetValid(const optimizer_coords_t& target) const;

    // selecting the best inital point for the local optimizer
    // assumes there are valid trajectories stored in optimizerInfo_
    void selectBestInitialPoint(const std::vector<optimizer_coords_t>& initialGuesses,
                                double x[kOptimizationDimension]);
    std::size_t bestTrajectoryIdx(void);

    // optimizers
    nlopt_opt globalOptimizer;
    nlopt_opt localOptimizer;

    optimizer_coords_t coordEvaluated_;

    double globalOptimizerSeed_[kOptimizationDimension];

    // simulator and evaluator
    RobotSimulator*      simulator_;
    TrajectoryEvaluator* evaluator_;

    robot_trajectory_info_t trajectory;     // Trajectory to use for everything -- just reset it before each use

    // debug info
    trajectory_planner_debug_info_t* optimizerInfo_;

    // a set of initial guesses for optmization
    std::vector<optimizer_coords_t> defaultGuesses_;
    std::vector<optimizer_coords_t> newGuesses_;

    // inital robot state
    pose_t robotPose_;

    // indicator for finding a right solution
    bool haveFoundSolution_;

    // parameters
    mpepc_optimizer_params_t params_;
};


} // mpepc
} // vulcan

#endif // MPEPC_OPTIMIZER_H
